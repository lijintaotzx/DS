# 递归

## 定义
编写递归函数的时候，必须告诉它如何停止，正因为如此，每个递归函数都有两部分：基线条件和递归条件，递归条件指的是函数调用自己，而基线函数则指的是函数不再调用自己，从而避免形成无线循环。
```python
def count_down(n):
  print(n)
  if n <= 1:  # 基线条件
    return
  else:   # 递归条件
    count_down(n-1)
    
```

## 递归过程的实现
一般来说，在计算机中实现函数的调用，可分为以下3个步骤
1. 保存调用信息，其中主要是返回地址信息和实参信息。
2. 分配调用过程中所需要的数据区。（分配内存）
3. 把控制转移到被调用过程的入口。

当被调用的算法运行结束需要返回到调用算法时，一般也分以下3个步骤：
1. 保存返回时的有关信息，如计算结果等。
2. 释放被调用算法占用的数据区。（释放内存）
3. 把执行控制按调用时保存的返回地址转移到调用算法中调用语句的下一条语句。

递归一般情况下不节省时间，也不节省空间，因为它依赖系统中的运行栈（对用户来说不可见），来保存每次调用时候的参数，变量与返回信息等，但是递归函数易于理解，结构清晰，便于阅读
递归运行效率低，无论从空间还是时间角度，都不如非递归函数，但在更多的时候，程序的结构简单和可读性更为重要，以下两种情况，尽量不要使用递归：
1. 程序中非常频繁使用的部分。
2. 进行程序设计的语言（如Fortran语言和大多数汇编）不允许使用递归。

## 递归算法到非递归算法的转换
```python
# 阶乘
# 递归
def fact(n):
  if n == 0:
    return 1
  else:
    return n * fact(n - 1)

# 非递归
def norec_fact(n):
  res = 1
  st = SStack()   # 自己管理栈，也可以使用列表，或者自己写
  
  while n > 0:
    st.push(n)
    n -= 1
    
  while not st.is_empty():
    res *= st.pop()
    
  return res
  
```

## 递归对程序压栈的理解
```python
def func01(n)
  print(n)
  if n <= 0:
    return
  else:
    func01(n-1)
  
  func01(3)
  # 3
  # 2
  # 1
  # 0
  
 def func02(n):
  if n <= 0:
    return
  else:
    func02(n-1)
    print(n)
 
 func02(3)
 # 1
 # 2
 # 3

```
